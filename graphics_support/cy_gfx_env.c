/**********************************************************************************************************************
 * \file cy_gfx_env.c
 * \copyright Copyright (C) Infineon Technologies AG 2025
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*****************************************************************************
* Include files
*****************************************************************************/
#include "cy_device_headers.h"
#include "cycfg_peripherals.h"
#include "cy_retarget_io.h"
#include "cy_gfx_env.h"
#include "mtb_hal.h"

#if defined(__cplusplus)
extern "C" {
#endif

/*****************************************************************************
* Local pre-processor symbols/macros ('define')
*****************************************************************************/
/* Clokc related macros */

#define DISP0_CLK_PLL_MIN_HZ                      110000000UL
#define DISP0_CLK_PLL_MAX_HZ                      220000000UL
#define DISP1_CLK_PLL_MIN_HZ                      110000000UL
#define DISP1_CLK_PLL_MAX_HZ                      200000000UL  /* 220 max if a PLL400M would be used*/

#define VIDEOSS_FIXED_DISP_CLK_DIV                2  /* Fixed "divide-by-2" in the display clock path*/
#define CLK_PATH_DISP0_CLK                        5  /* PLL400M #4*/
#define CLK_PATH_DISP1_CLK                        8  /* PLL200M #2*/
#define CLK_PATH_SMIF_CLK                         3  /* PLL400M #2*/
#define CLK_DIV_TO_REG_VAL(div)                   (((div) == 8) ? 3 : ((div) == 4) ? 2 : ((div) == 2) ? 1 : 0)

/* Macros needed to generate the VIDEOSS TCON mapping values */ 

#define R(bit)                                    ((bit) +  0)
#define G(bit)                                    ((bit) +  8)
#define B(bit)                                    ((bit) + 16)
#define HSYNC                                     (24)
#define VSYNC                                     (25)
#define DEN                                       (26)
#define RES                                       (27)
#define MAP_VALUE(n0,n1,n2,n3)                    (((n3)<<24) + ((n2)<<16) + ((n1)<<8) +(n0))

#define MAP_INDEX_JEIDA                           0
#define MAP_INDEX_VESA                            1

/* SMIF and HyperBus related macros */

#define GFXENV_SMIF_TIMEOUT                       1000
#define GFXENV_S27K_INITIAL_LATENCY               CY_SMIF_HB_LC7
#define GFXENV_S27K_MAX_CS_LOW_NS                 1000UL          /* t_CMS in nanoseconds*/

#define GFXENV_SMIF_MDL_TAP_XSPI400               6
#define GFXENV_SMIF_MDL_TAP_XSPI333               6
#define GFXENV_SMIF_MDL_TAP_XSPI266               6
#define GFXENV_SMIF_MDL_TAP_XSPI200               6

#define GFXENV_SMIF_SDL_TAP_XSPI400               0
#define GFXENV_SMIF_SDL_TAP_XSPI333               0
#define GFXENV_SMIF_SDL_TAP_XSPI266               1
#define GFXENV_SMIF_SDL_TAP_XSPI200               2

#define GFXENV_SMIF_GET_DLL_DIVIDER_FROM_ENUM(enum_val)    ((enum_val == 0) ? 2 : (enum_val == 1) ? 4 : (enum_val == 2) ? 8 : 16)
#define GFXENV_SMIF_GET_DLL_ENUM_FROM_DIVIDER(div_val)     ((div_val == 2) ? CY_SMIF_MDL_CLK_OUT_DIV2 : (div_val == 4) ? CY_SMIF_MDL_CLK_OUT_DIV4 : (div_val == 8) ? CY_SMIF_MDL_CLK_OUT_DIV8 : CY_SMIF_MDL_CLK_OUT_DIV16)

/*****************************************************************************
* Global variable definitions (declared in header file with 'extern')
*****************************************************************************/
/* For the Retarget -IO (Debug UART) usage */
static cy_stc_scb_uart_context_t    UART_context;           /* UART context */
static mtb_hal_uart_t               UART_hal_obj;           /* Debug UART HAL object  */
uint32_t counterTick = 0;

/* The definition for Power Enble */ 
#define PD_BASE                                 0x40B00000UL
#define PD_CTL_PWR_MODE_Msk                     0x3UL
#define PD_STATUS_PWR_DONE_Msk                  0x10UL

/*****************************************************************************
* Local type definitions ('typedef')
*****************************************************************************/

/*****************************************************************************
 ** \brief Port pin group enumeration type
 *****************************************************************************/
typedef enum
{
    Display0,
    Display1,
    Capture0,
    Smif0,
    Smif1,
    BlDisp0,
    BlDisp1,
    BlFpd0,
    BlFpd1,
    Button,
} en_portpin_group_t;

/*****************************************************************************
 ** \brief Port pin configuration type
 *****************************************************************************/
typedef struct
{
    en_portpin_group_t          enGroup;
    GPIO_PRT_Type*              pstcPort;
    uint8_t                     u8Pin;
    en_hsiom_sel_t              enMuxCfg;
    uint8_t                     u8DriveMode;
    uint8_t                     u8GpioOutVal;
} stc_portpin_cfg_t;

/*****************************************************************************
 ** \brief Display presets type
 *****************************************************************************/
typedef struct
{
    uint16_t  u16HorizontalActive;
    uint16_t  u16HorizontalTotal;
    uint16_t  u16VerticalActive;
    uint16_t  u16VerticalTotal;
    uint8_t   u8RefreshRateHz;
    bool      bUseFpd;
    uint8_t   u8MapIndex;
} stc_display_presets_t;

/*****************************************************************************
* Local variable definitions ('static')
*****************************************************************************/

/*****************************************************************************
 ** \brief Display presets
 *****************************************************************************/
/*****************************************************************************
 ** \brief FPD/LVDS Signal Mapping
 *****************************************************************************/
/*****************************************************************************
 ** \brief Port pin configuration
 *****************************************************************************/
static const stc_portpin_cfg_t m_astcPortPinCfg[] =
{
#ifdef CY_BSP_HDR_DISP0_TTL_AVAILABLE
    { .enGroup = Display0, .pstcPort = CY_DISP0_CLK_PORT,        .u8Pin = CY_DISP0_CLK_PIN,        .enMuxCfg = CY_DISP0_CLK_PIN_MUX,        .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_CTRL0_PORT,      .u8Pin = CY_DISP0_CTRL0_PIN,      .enMuxCfg = CY_DISP0_CTRL0_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_CTRL1_PORT,      .u8Pin = CY_DISP0_CTRL1_PIN,      .enMuxCfg = CY_DISP0_CTRL1_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_CTRL2_PORT,      .u8Pin = CY_DISP0_CTRL2_PIN,      .enMuxCfg = CY_DISP0_CTRL2_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_0_PORT,  .u8Pin = CY_DISP0_DATA_A0_0_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_0_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_1_PORT,  .u8Pin = CY_DISP0_DATA_A0_1_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_1_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_2_PORT,  .u8Pin = CY_DISP0_DATA_A0_2_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_2_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_3_PORT,  .u8Pin = CY_DISP0_DATA_A0_3_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_3_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_4_PORT,  .u8Pin = CY_DISP0_DATA_A0_4_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_4_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_5_PORT,  .u8Pin = CY_DISP0_DATA_A0_5_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_5_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_6_PORT,  .u8Pin = CY_DISP0_DATA_A0_6_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_6_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_7_PORT,  .u8Pin = CY_DISP0_DATA_A0_7_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_7_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_8_PORT,  .u8Pin = CY_DISP0_DATA_A0_8_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_8_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_9_PORT,  .u8Pin = CY_DISP0_DATA_A0_9_PIN,  .enMuxCfg = CY_DISP0_DATA_A0_9_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_10_PORT, .u8Pin = CY_DISP0_DATA_A0_10_PIN, .enMuxCfg = CY_DISP0_DATA_A0_10_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A0_11_PORT, .u8Pin = CY_DISP0_DATA_A0_11_PIN, .enMuxCfg = CY_DISP0_DATA_A0_11_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_0_PORT,  .u8Pin = CY_DISP0_DATA_A1_0_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_0_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_1_PORT,  .u8Pin = CY_DISP0_DATA_A1_1_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_1_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_2_PORT,  .u8Pin = CY_DISP0_DATA_A1_2_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_2_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_3_PORT,  .u8Pin = CY_DISP0_DATA_A1_3_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_3_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_4_PORT,  .u8Pin = CY_DISP0_DATA_A1_4_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_4_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_5_PORT,  .u8Pin = CY_DISP0_DATA_A1_5_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_5_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_6_PORT,  .u8Pin = CY_DISP0_DATA_A1_6_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_6_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_7_PORT,  .u8Pin = CY_DISP0_DATA_A1_7_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_7_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_8_PORT,  .u8Pin = CY_DISP0_DATA_A1_8_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_8_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_9_PORT,  .u8Pin = CY_DISP0_DATA_A1_9_PIN,  .enMuxCfg = CY_DISP0_DATA_A1_9_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_10_PORT, .u8Pin = CY_DISP0_DATA_A1_10_PIN, .enMuxCfg = CY_DISP0_DATA_A1_10_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display0, .pstcPort = CY_DISP0_DATA_A1_11_PORT, .u8Pin = CY_DISP0_DATA_A1_11_PIN, .enMuxCfg = CY_DISP0_DATA_A1_11_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
#endif

#ifdef CY_BSP_HDR_DISP1_TTL_AVAILABLE
    { .enGroup = Display1, .pstcPort = CY_DISP1_CLK_PORT,        .u8Pin = CY_DISP1_CLK_PIN,        .enMuxCfg = CY_DISP1_CLK_PIN_MUX,        .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_CTRL0_PORT,      .u8Pin = CY_DISP1_CTRL0_PIN,      .enMuxCfg = CY_DISP1_CTRL0_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_CTRL1_PORT,      .u8Pin = CY_DISP1_CTRL1_PIN,      .enMuxCfg = CY_DISP1_CTRL1_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_CTRL2_PORT,      .u8Pin = CY_DISP1_CTRL2_PIN,      .enMuxCfg = CY_DISP1_CTRL2_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_0_PORT,  .u8Pin = CY_DISP1_DATA_A0_0_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_0_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_1_PORT,  .u8Pin = CY_DISP1_DATA_A0_1_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_1_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_2_PORT,  .u8Pin = CY_DISP1_DATA_A0_2_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_2_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_3_PORT,  .u8Pin = CY_DISP1_DATA_A0_3_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_3_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_4_PORT,  .u8Pin = CY_DISP1_DATA_A0_4_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_4_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_5_PORT,  .u8Pin = CY_DISP1_DATA_A0_5_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_5_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_6_PORT,  .u8Pin = CY_DISP1_DATA_A0_6_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_6_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_7_PORT,  .u8Pin = CY_DISP1_DATA_A0_7_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_7_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_8_PORT,  .u8Pin = CY_DISP1_DATA_A0_8_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_8_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_9_PORT,  .u8Pin = CY_DISP1_DATA_A0_9_PIN,  .enMuxCfg = CY_DISP1_DATA_A0_9_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_10_PORT, .u8Pin = CY_DISP1_DATA_A0_10_PIN, .enMuxCfg = CY_DISP1_DATA_A0_10_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A0_11_PORT, .u8Pin = CY_DISP1_DATA_A0_11_PIN, .enMuxCfg = CY_DISP1_DATA_A0_11_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_0_PORT,  .u8Pin = CY_DISP1_DATA_A1_0_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_0_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_1_PORT,  .u8Pin = CY_DISP1_DATA_A1_1_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_1_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_2_PORT,  .u8Pin = CY_DISP1_DATA_A1_2_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_2_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_3_PORT,  .u8Pin = CY_DISP1_DATA_A1_3_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_3_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_4_PORT,  .u8Pin = CY_DISP1_DATA_A1_4_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_4_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_5_PORT,  .u8Pin = CY_DISP1_DATA_A1_5_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_5_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_6_PORT,  .u8Pin = CY_DISP1_DATA_A1_6_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_6_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_7_PORT,  .u8Pin = CY_DISP1_DATA_A1_7_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_7_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_8_PORT,  .u8Pin = CY_DISP1_DATA_A1_8_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_8_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_9_PORT,  .u8Pin = CY_DISP1_DATA_A1_9_PIN,  .enMuxCfg = CY_DISP1_DATA_A1_9_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_10_PORT, .u8Pin = CY_DISP1_DATA_A1_10_PIN, .enMuxCfg = CY_DISP1_DATA_A1_10_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
    { .enGroup = Display1, .pstcPort = CY_DISP1_DATA_A1_11_PORT, .u8Pin = CY_DISP1_DATA_A1_11_PIN, .enMuxCfg = CY_DISP1_DATA_A1_11_PIN_MUX, .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 0 },
#endif

#ifdef CY_BSP_HDR_CAP0_TTL_AVAILABLE
    { .enGroup = Capture0, .pstcPort = CY_CAP0_CLK_PORT,         .u8Pin = CY_CAP0_CLK_PIN,         .enMuxCfg = CY_CAP0_CLK_PIN_MUX,         .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA0_PORT,       .u8Pin = CY_CAP0_DATA0_PIN,       .enMuxCfg = CY_CAP0_DATA0_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA1_PORT,       .u8Pin = CY_CAP0_DATA1_PIN,       .enMuxCfg = CY_CAP0_DATA1_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA2_PORT,       .u8Pin = CY_CAP0_DATA2_PIN,       .enMuxCfg = CY_CAP0_DATA2_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA3_PORT,       .u8Pin = CY_CAP0_DATA3_PIN,       .enMuxCfg = CY_CAP0_DATA3_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA4_PORT,       .u8Pin = CY_CAP0_DATA4_PIN,       .enMuxCfg = CY_CAP0_DATA4_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA5_PORT,       .u8Pin = CY_CAP0_DATA5_PIN,       .enMuxCfg = CY_CAP0_DATA5_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA6_PORT,       .u8Pin = CY_CAP0_DATA6_PIN,       .enMuxCfg = CY_CAP0_DATA6_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA7_PORT,       .u8Pin = CY_CAP0_DATA7_PIN,       .enMuxCfg = CY_CAP0_DATA7_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA8_PORT,       .u8Pin = CY_CAP0_DATA8_PIN,       .enMuxCfg = CY_CAP0_DATA8_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA9_PORT,       .u8Pin = CY_CAP0_DATA9_PIN,       .enMuxCfg = CY_CAP0_DATA9_PIN_MUX,       .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA10_PORT,      .u8Pin = CY_CAP0_DATA10_PIN,      .enMuxCfg = CY_CAP0_DATA10_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA11_PORT,      .u8Pin = CY_CAP0_DATA11_PIN,      .enMuxCfg = CY_CAP0_DATA11_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA12_PORT,      .u8Pin = CY_CAP0_DATA12_PIN,      .enMuxCfg = CY_CAP0_DATA12_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA13_PORT,      .u8Pin = CY_CAP0_DATA13_PIN,      .enMuxCfg = CY_CAP0_DATA13_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA14_PORT,      .u8Pin = CY_CAP0_DATA14_PIN,      .enMuxCfg = CY_CAP0_DATA14_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA15_PORT,      .u8Pin = CY_CAP0_DATA15_PIN,      .enMuxCfg = CY_CAP0_DATA15_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA16_PORT,      .u8Pin = CY_CAP0_DATA16_PIN,      .enMuxCfg = CY_CAP0_DATA16_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA17_PORT,      .u8Pin = CY_CAP0_DATA17_PIN,      .enMuxCfg = CY_CAP0_DATA17_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA18_PORT,      .u8Pin = CY_CAP0_DATA18_PIN,      .enMuxCfg = CY_CAP0_DATA18_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA19_PORT,      .u8Pin = CY_CAP0_DATA19_PIN,      .enMuxCfg = CY_CAP0_DATA19_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA20_PORT,      .u8Pin = CY_CAP0_DATA20_PIN,      .enMuxCfg = CY_CAP0_DATA20_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA21_PORT,      .u8Pin = CY_CAP0_DATA21_PIN,      .enMuxCfg = CY_CAP0_DATA21_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA22_PORT,      .u8Pin = CY_CAP0_DATA22_PIN,      .enMuxCfg = CY_CAP0_DATA22_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA23_PORT,      .u8Pin = CY_CAP0_DATA23_PIN,      .enMuxCfg = CY_CAP0_DATA23_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA24_PORT,      .u8Pin = CY_CAP0_DATA24_PIN,      .enMuxCfg = CY_CAP0_DATA24_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA25_PORT,      .u8Pin = CY_CAP0_DATA25_PIN,      .enMuxCfg = CY_CAP0_DATA25_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
    { .enGroup = Capture0, .pstcPort = CY_CAP0_DATA26_PORT,      .u8Pin = CY_CAP0_DATA26_PIN,      .enMuxCfg = CY_CAP0_DATA26_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_HIGHZ,  .u8GpioOutVal = 0 },
#endif

  #ifdef CY_BL_DISP0_EN_PORT
    { .enGroup = BlDisp0,  .pstcPort = CY_BL_DISP0_EN_PORT,      .u8Pin = CY_BL_DISP0_EN_PIN,      .enMuxCfg = CY_BL_DISP0_EN_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_BL_DISP0_PWM_PORT
    { .enGroup = BlDisp0,  .pstcPort = CY_BL_DISP0_PWM_PORT,     .u8Pin = CY_BL_DISP0_PWM_PIN,     .enMuxCfg = CY_BL_DISP0_PWM_PIN_MUX,     .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_FPDLINK0_BL_EN_PORT
    { .enGroup = BlFpd0,   .pstcPort = CY_FPDLINK0_BL_EN_PORT,   .u8Pin = CY_FPDLINK0_BL_EN_PIN,   .enMuxCfg = CY_FPDLINK0_BL_EN_PIN_MUX,   .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_FPDLINK0_BL_PWM_PORT
    { .enGroup = BlFpd0,   .pstcPort = CY_FPDLINK0_BL_PWM_PORT,  .u8Pin = CY_FPDLINK0_BL_PWM_PIN,  .enMuxCfg = CY_FPDLINK0_BL_PWM_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif

  #ifdef CY_BL_DISP1_EN_PORT
    { .enGroup = BlDisp1,  .pstcPort = CY_BL_DISP1_EN_PORT,      .u8Pin = CY_BL_DISP1_EN_PIN,      .enMuxCfg = CY_BL_DISP1_EN_PIN_MUX,      .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 }, 
  #endif
  #ifdef CY_BL_DISP1_PWM_PORT
    { .enGroup = BlDisp1,  .pstcPort = CY_BL_DISP1_PWM_PORT,     .u8Pin = CY_BL_DISP1_PWM_PIN,     .enMuxCfg = CY_BL_DISP1_PWM_PIN_MUX,     .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_FPDLINK1_BL_EN_PORT
    { .enGroup = BlFpd1,   .pstcPort = CY_FPDLINK1_BL_EN_PORT,   .u8Pin = CY_FPDLINK1_BL_EN_PIN,   .enMuxCfg = CY_FPDLINK1_BL_EN_PIN_MUX,   .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif
  #ifdef CY_FPDLINK1_BL_PWM_PORT
    { .enGroup = BlFpd1,   .pstcPort = CY_FPDLINK1_BL_PWM_PORT,  .u8Pin = CY_FPDLINK1_BL_PWM_PIN,  .enMuxCfg = CY_FPDLINK1_BL_PWM_PIN_MUX,  .u8DriveMode = CY_GPIO_DM_STRONG, .u8GpioOutVal = 1 },
  #endif

};

/*****************************************************************************
 ** \brief Hold GfxEnv driver internal config/status of all SMIFs and SMIF_DEVICEs
 *****************************************************************************/

/*****************************************************************************
* Local function prototypes ('static')
*****************************************************************************/
static void                  InitPortPins                   (const cy_gfxenv_stc_init_portpins_t * pstcPortInitCfg);

/*****************************************************************************
* Function implementation - global ('extern') and local ('static')
*****************************************************************************/

/*******************************************************************************
* Function Name: Cy_GfxEnv_Init
********************************************************************************
*
* \brief  Initializes the GFX environment
*
* \param  pstcGfxEnvCfg : The pointer to the init configuration struct
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/
cy_gfxenv_en_result_t Cy_GfxEnv_Init(const cy_gfxenv_stc_cfg_t *pstcGfxEnvCfg)
{
    /* Initialize port pins if requested by user configuration*/
    if(pstcGfxEnvCfg->pstcInitPortPins != NULL)
    {
        InitPortPins(pstcGfxEnvCfg->pstcInitPortPins);
    }

    /*Initialize software timer module if requested by user configuration*/
    if(pstcGfxEnvCfg->bInitSwTimer != false)
    {
        /* Reset tick counter*/
        m_u64TickCountUs = 0;

        Cy_SysTick_Init(CY_SYSTICK_CLOCK_SOURCE_CLK_IMO, SYSTICK_RELOAD_VALUE);
        Cy_SysTick_SetCallback(0, NULL);
    }

    /* Initialize semihosting (low level I/O) together with required clock and port pin setup if requested by user configuration*/
    if(pstcGfxEnvCfg->bInitSemihosting != false)
    {
    
        /* Initialize retarget-io to use the debug UART port */
        Cy_SCB_UART_Init(UART_HW, &UART_config, &UART_context);
        Cy_SCB_UART_Enable(UART_HW);

        mtb_hal_uart_setup(&UART_hal_obj, &UART_hal_config, &UART_context, NULL);
        cy_retarget_io_init(&UART_hal_obj);

        /*printf("Active PLL0: %u\n");*/
        /*printf("Active PLL1: %u\n");*/
    }

    return CY_GFXENV_SUCCESS;
}


/*******************************************************************************
* Function Name: Cy_GfxEnv_FastInit
********************************************************************************
*
* \brief  Initializes the GFX environment with most commonly used settings.
*         Only a limited number of parameters can be configured, e.g.
*         whether SMIF instances and connected memories are initialized
*         because this would stuck execution if memory is not connected or in
*         case of signal problems.
*
* \warning u8Smif0ExtClockMhz and u8Smif1ExtClockMhz ratio needs to be 1, 2, 4 or 8 
*          (or 1, 0.5, 0.25, 0.125 respectively) at the moment, because by default
*          the SMIF HF clocks use the same source PLL and hence only the HF clock
*          dividers can be used
*
* \param  u8Smif0ExtClockMhz : SMIF0 external clock frequency,
*                              if value == 0, SMIF0 will not be initialized
* \param  u8Smif1ExtClockMhz : SMIF1 external clock frequency,
*                              if value == 0, SMIF1 will not be initialized
* \param  pfnButtonCallback  : Callback from button handler, can be NULL (then
*                              button driver and port pins are not initialized)
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/
cy_gfxenv_en_result_t Cy_GfxEnv_FastInit(uint8_t u8Smif0ExtClockMhz, uint8_t u8Smif1ExtClockMhz, cy_button_callback_t pfnButtonCallback)
{
    cy_gfxenv_stc_cfg_t stcGfxEnvCfg =
    {
        .bInitSwTimer         = true,
        .bInitSemihosting     = true,
        .pstcInitPortPins     = &(cy_gfxenv_stc_init_portpins_t)
                                {
                                  #if (CY_USE_PSVP == 0)
                                    .bInitDisplay0Ttl       = false, /* usually the FPD-Link is used on silicon*/
                                  #else
                                    .bInitDisplay0Ttl       = true,  /* FPD-Link #0 is not available on PSVP*/
                                  #endif
                                  #if (CY_USE_PSVP == 0) && defined(VIDEOSS0_FPDLINK1)
                                    .bInitDisplay1Ttl       = true, /* usually the FPD-Link is used on silicon (if it is available)*/
                                  #else
                                    .bInitDisplay1Ttl       = true,  /* FPD-Link #1 is not available on PSVP or on silicon for this device*/
                                  #endif
                                    .bInitCapture0Ttl       = false,
                                    .bInitSmif0             = true,  /* might be overriden by function parameter u8Smif0ExtClockMhz*/
                                    .bInitSmif1             = true,  /* might be overriden by function parameter u8Smif1ExtClockMhz*/
                                    .bInitBacklightDisp0    = false, /* backlights are enabled by jumper setting on CY boards, would only be needed for PWM dimming*/
                                    .bInitBacklightDisp1    = false, /* backlights are enabled by jumper setting on CY boards, would only be needed for PWM dimming*/
                                    .bInitBacklightFpdLink0 = false, /* backlights are enabled by jumper setting on CY boards, would only be needed for PWM dimming*/
                                    .bInitBacklightFpdLink1 = false, /* backlights are enabled by jumper setting on CY boards, would only be needed for PWM dimming*/
                                    .bInitButtonGpios       = true,
                                },
        .pstcInitExtMem       = &(cy_gfxenv_stc_init_extmem_t)
                                {
                                    .bInitMpuTemporarily = true,
                                    .u8MpuRegionTemp     = CY_GFXENV_SMIF_TEMP_MPU_REGION,
                                    .apstcInitSmif       = {
                                                                &(cy_gfxenv_stc_smif_cfg_t)
                                                                {
                                                                    .u8SmifExtClockMhz = 0, /* updated by function parameter*/
                                                                    .apstcDevUsrCfg    = {
                                                                                             &(cy_gfxenv_stc_smif_device_cfg_t)
                                                                                             {
                                                                                                 .u32BaseAddress           = CY_GFXENV_FASTINIT_EXTMEM_FLASH_BASE,
                                                                                                 .u16SizeMegaBytes         = 64,
                                                                                                 .enExtMemType             = CY_GFXENV_EXTMEM_TYPE_S28H,
                                                                                             },
                                                                                             NULL,
                                                                                         },
                                                                }, 
                                                                &(cy_gfxenv_stc_smif_cfg_t)
                                                                {
                                                                    .u8SmifExtClockMhz = 0, /* updated by function parameter*/
                                                                    .apstcDevUsrCfg    = {
                                                                                             NULL,
                                                                                             &(cy_gfxenv_stc_smif_device_cfg_t)
                                                                                             {
                                                                                                 .u32BaseAddress           = CY_GFXENV_FASTINIT_EXTMEM_RAM_BASE,
                                                                                                 .u16SizeMegaBytes         = 8,
                                                                                                 .enExtMemType             = CY_GFXENV_EXTMEM_TYPE_S27KXXXX2,
                                                                                             },
                                                                                         },
                                                                },
                                                            },
                                },
        .pstcInitButtons      = &(cy_gfxenv_stc_init_buttons_t)
                                {
                                    .u8CySwTimerId = (CY_SWTMR_MAX_TIMERS - 1), /* use last timer*/
                                    .pfnCallback   = NULL,
                                },

    };

    /* Disable SMIF clock, port and memory initialization if not requested by user, otherwise update the frequency with value from user*/
    if(u8Smif0ExtClockMhz == 0)
    {
        stcGfxEnvCfg.pstcInitPortPins->bInitSmif0 = false;
        stcGfxEnvCfg.pstcInitExtMem->apstcInitSmif[0] = NULL;
    }
    else
    {
        stcGfxEnvCfg.pstcInitExtMem->apstcInitSmif[0]->u8SmifExtClockMhz = u8Smif0ExtClockMhz;
    }
    if(u8Smif1ExtClockMhz == 0)
    {
        stcGfxEnvCfg.pstcInitPortPins->bInitSmif1 = false;
        stcGfxEnvCfg.pstcInitExtMem->apstcInitSmif[1] = NULL;
    }    
    else
    {
        stcGfxEnvCfg.pstcInitExtMem->apstcInitSmif[1]->u8SmifExtClockMhz = u8Smif1ExtClockMhz;
    }
    if((u8Smif0ExtClockMhz == 0) && (u8Smif1ExtClockMhz == 0))
    {
        stcGfxEnvCfg.pstcInitExtMem = NULL;
    }

    /* Disable button driver and corresponding port pin initialization if user does not provide callback*/
    if(pfnButtonCallback == NULL)
    {
        stcGfxEnvCfg.pstcInitButtons = NULL;
    }
    else
    {
        stcGfxEnvCfg.pstcInitButtons->pfnCallback = pfnButtonCallback;
    }

    return Cy_GfxEnv_Init(&stcGfxEnvCfg);
}

/*******************************************************************************
* Function Name: InitPortPins
********************************************************************************
*
* \brief  Initializes all port pins that shall be configured according to user
*         configuration.
*
* \param  pstcCfg : Pointer to to port pin config struct member of GFX Env
*                   config struct
*
*******************************************************************************/
static void InitPortPins(const cy_gfxenv_stc_init_portpins_t * pstcPortInitCfg)
{
    for(uint16_t u16Index = 0; u16Index < CY_GET_ARRAY_LEN(m_astcPortPinCfg); u16Index++)
    {
        const stc_portpin_cfg_t * pstcCurPortPin = &m_astcPortPinCfg[u16Index];

        /* Skip this loop iteration if the current port pin cfg belongs to a group that shall not be initialized*/
        switch(pstcCurPortPin->enGroup)
        {
            case Display0:
                if(pstcPortInitCfg->bInitDisplay0Ttl == false)
                {
                    continue;
                }
                break;
            case Display1:
                if(pstcPortInitCfg->bInitDisplay1Ttl == false)
                {
                    continue;
                }
                break;
            case Capture0:
                if(pstcPortInitCfg->bInitCapture0Ttl == false)
                {
                    continue;
                }
                break;
            case Smif0:
                if(pstcPortInitCfg->bInitSmif0 == false)
                {
                    continue;
                }
                break;
            case Smif1:
                if(pstcPortInitCfg->bInitSmif1 == false)
                {
                    continue;
                }
                break;
            case BlDisp0:
                if(pstcPortInitCfg->bInitBacklightDisp0 == false)
                {
                    continue;
                }
                break;
            case BlDisp1:
                if(pstcPortInitCfg->bInitBacklightDisp1 == false)
                {
                    continue;
                }
                break;
            case BlFpd0:
                if(pstcPortInitCfg->bInitBacklightFpdLink0 == false)
                {
                    continue;
                }
                break;
            case BlFpd1:
              #ifdef VIDEOSS0_FPDLINK1
                if(pstcPortInitCfg->bInitBacklightFpdLink1 == false)
                {
                    continue;
                }
                break;
              #else
                continue;
              #endif
            case Button:
                if(pstcPortInitCfg->bInitButtonGpios == false)
                {
                    continue;
                }
                break;
            default:
                break;
        }

        /* If more detailed port pin settings need to be made (e.g. input trip point, slew rate, drive strength)*/
        /* the implementation must be changed to use Cy_GPIO_Pin_Init API*/
        Cy_GPIO_Pin_FastInit( pstcCurPortPin->pstcPort,
                              pstcCurPortPin->u8Pin,
                              pstcCurPortPin->u8DriveMode,
                              pstcCurPortPin->u8GpioOutVal,
                              pstcCurPortPin->enMuxCfg      );

    }
}

/*******************************************************************************
* Function Name: Cy_SwTmr_GetTickCountUs
********************************************************************************
*
*  Summary:
*  Systick interrupt handler
*
*  Parameters:
*  None
*
*  Return:
*  None
*
**********************************************************************************/
uint64_t Cy_SwTmr_GetTickCountUs(void)
{
    return counterTick;
}
/*******************************************************************************
* Function Name: toggle_led_on_systick_handler
********************************************************************************
*
*  Summary:
*  Systick interrupt handler
*
*  Parameters:
*  None
*
*  Return:
*  None
*
**********************************************************************************/
void toggle_led_on_systick_handler(void)
{
    counterTick++;
}
/*******************************************************************************
* Function Name: Cy_Fpdlink_Init
********************************************************************************
*
*  Summary:
*  Initiliza the FPDLINK
*  Note: Currently the FPDLink funstion is not supported,
*  thus only empty function is created to avoid the build error.
*
*  Parameters:
*  None
*
*  Return:
*  None
*
**********************************************************************************/
cy_fpdlink_en_result_t Cy_Fpdlink_Init(cy_fpdlink_en_instance_t enFpdlink, const cy_fpdlink_stc_cfg_t * pstcCfg)
{
    return CY_FPDLINK_SUCCESS;
}

/*******************************************************************************
* Function Name: Cy_PD_Enable
********************************************************************************
*
*  Summary:
*  Enable Graphics Subsystem Power Switch
*
*  Parameters:
*  None
*
*  Return:
*  None
*
**********************************************************************************/
void Cy_PD_Enable(void)
{
    const uint32_t pdCtl    = PD_BASE;
    const uint32_t pdStatus = PD_BASE + 0x10;

    *((volatile uint32_t *)pdCtl) |= PD_CTL_PWR_MODE_Msk;
    while ((*((volatile uint32_t *)pdStatus) & PD_STATUS_PWR_DONE_Msk) == 0);
    *(int*)(0x40A00000) = 0x80000000;
}

#if defined(__cplusplus)
}
#endif


/* [] END OF FILE */
