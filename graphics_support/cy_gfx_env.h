/**********************************************************************************************************************
 * \file cy_gfx_env.h
 * \copyright Copyright (C) Infineon Technologies AG 2025
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/**
* \defgroup group_gfxenv Middleware GFX Environment (MW GfxEnv)
* \{
* The GfxEnv middleware provides an API to setup the environment for GFX application.
*
* \defgroup group_gfxenv_macros Macro
* \defgroup group_gfxenv_functions Functions
* \defgroup group_gfxenv_data_structures Data structures
* \defgroup group_gfxenv_enums Enumerated Types
*/


#if !defined(CY_GFXENV_H)
#define CY_GFXENV_H

#include <stddef.h>
#include <stdbool.h>
#include "cy_systick.h"
#include "cy_fpdlink.h"

#if defined(__cplusplus)
extern "C" {
#endif

/**
* \addtogroup group_gfxenv_macros
* \{
*/
/* Button IDs (button driver is initialized by GfxEnv, application can use button driver with these IDs)*/
#define CY_GFXENV_BUTTON_ID_AB_CB    0x00  /* Button on PSVP adapter board (AB) or later CPU board (CB)*/
#define CY_GFXENV_BUTTON_ID_CEB      0x01  /* Button on Cluster Extension Board (CEB)*/
#define CY_GFXENV_BUTTON_ID_BB_1     0x11  /* Button on Base Board (BB)*/
#define CY_GFXENV_BUTTON_ID_BB_2     0x12  /* Button on Base Board (BB)*/
#define CY_GFXENV_BUTTON_ID_BB_3     0x13  /* Button on Base Board (BB)*/
#define CY_GFXENV_BUTTON_ID_BB_4     0x14  /* Button on Base Board (BB)*/
#define CY_GFXENV_BUTTON_ID_BB_5     0x15  /* Button on Base Board (BB)*/

#define CY_GFXENV_BUTTON_ID_SW1     0x20  /* Button "WAKE" (or CENTER) on CPU Board*/
#define CY_GFXENV_BUTTON_ID_SW2     0x21  /* Button "LEFT" on CPU Board*/

/**
* Number of SMIF "instances" or "cores" (depending on IP revision) (or in other words: the number of the architecural units that comprise the SMIF DEVICEs)
*/
#if (CY_IP_MXSMIF_VERSION >= 4)
    #define CY_GFXENV_NR_OF_SMIF                  (CY_IP_MXSMIF_INSTANCES * 2) /* new SMIF architecture: Instance -> n Cores -> m Devices/Core (n, m := 2 for all current devices with this IP version)*/
#else
    #define CY_GFXENV_NR_OF_SMIF                  (CY_IP_MXSMIF_INSTANCES)     /* old SMIF architecture: Instance -> m Devices/Instance (m := 2 for all current devices with this IP version)*/
#endif
        
/**
* Number of DEVICES per SMIF "instance" or "core" (depending on IP revision)
*/
#if defined(SMIF0_DEVICE_NR)
  #define CY_SMIF_DRV_SMIF0_DEVICE_NR                 SMIF0_DEVICE_NR
#elif defined(SMIF_DEVICE_NR)
  #define CY_SMIF_DRV_SMIF0_DEVICE_NR                 SMIF_DEVICE_NR
#endif

#define CY_GFXENV_NR_OF_DEVICES_PER_SMIF          CY_SMIF_DRV_SMIF0_DEVICE_NR

/**
* MPU region number which is used temporarily during SMIF init if feature enabled (use last region with highest priority)
*/
#if CY_CPU_CORTEX_M0P
    #define CY_GFXENV_SMIF_TEMP_MPU_REGION        7
#else
    #define CY_GFXENV_SMIF_TEMP_MPU_REGION        15
#endif

/**
* SCB Instance used for semihosting
*/
#define CY_GFXENV_SEMIHOSTING_SCB                 CY_USB_SCB_UART_TYPE

/**
* Optional watchdog handler function used during semihosting (e.g. blocking reads!)
*/
#define CY_GFXENV_SEMIHOSTING_WDG_HANDLER         NULL  /* or function of type cy_sw_tmr_wdg_handle_callout_t*/


/**
* Base address of external RAM when Cy_GfxEnv_FastInit is used to initialize the external memory
*/
#define CY_GFXENV_FASTINIT_EXTMEM_FLASH_BASE      0x60000000

/**
* Base address of external RAM when Cy_GfxEnv_FastInit is used to initialize the external memory
*/
#define CY_GFXENV_FASTINIT_EXTMEM_RAM_BASE        0x90000000

/** \} group_gfxenv_macros */


/* Returns the length of an array */
#define CY_GET_ARRAY_LEN(array)           (sizeof(array) / sizeof(array[0]))

/* Software Timer */
#define CY_SWTMR_MAX_TIMERS        5  /* must be <= 256*/
#define SYSTICK_RELOAD_VALUE       (((((8000000) / 1000) * (1000)) / 1000) - 1)
static volatile uint64_t m_u64TickCountUs;

typedef enum
{
    CY_SWTMR_SUCCESS   = 0x00u, /**< Returned successful */
    CY_SWTMR_BAD_PARAM = 0x01u, /**< Bad parameter was passed */
} cy_swtmr_en_result_t;

typedef void (*cy_sw_tmr_callback_t)(void);
typedef struct
{
    volatile int32_t      i32Timer;
    int32_t               i32Reload;
    cy_sw_tmr_callback_t  pfnCallback;
    volatile bool         bElapsed;
    bool                  bHighPrio;
} stc_sw_tmr_cfg_status_t;

/* Button state and definition */
typedef enum
{
    StateInvalid,
    StateLow,
    StateHigh
} cy_button_en_state_t;

typedef struct
{
    /*volatile stc_GPIO_PRT_t*    pstcPort;*/
    GPIO_PRT_Type*      pstcPort;
    uint8_t             u8Pin;
    uint8_t             u8ButtonId;
} cy_button_stc_definition_t;

typedef enum
{
    CY_BUTTON_SUCCESS   = 0x00u, /**< Returned successful */
    CY_BUTTON_ERROR     = 0x01u, /**< General error */
    CY_BUTTON_BAD_PARAM = 0x02u, /**< Bad parameter was passed */
} cy_button_en_result_t;

typedef struct
{
    cy_button_stc_definition_t  stcDef;
    uint8_t                     u8DebounceCounter;
    cy_button_en_state_t        enCurrState;
} stc_button_cfg_status_t;

typedef void (*cy_button_callback_t)(uint8_t u8ButtonId, cy_button_en_state_t enState);

/***************************************
*       Enumeration
***************************************/

/**
* \addtogroup group_gfxenv_enums
* \{
*/

/**
* Function return values
*/
typedef enum
{
    CY_GFXENV_SUCCESS                     = 0x00u,   /**< Returned successful */
    CY_GFXENV_ERROR                       = 0x01u,   /**< General error */
    CY_GFXENV_ERROR_BAD_PARAM             = 0x02u,   /**< Bad parameter was passed */
    CY_GFXENV_ERROR_EXTMEM_REG_READBACK   = 0x03u,   /**< Unexpected value from reading I/O register in an external memory */
    CY_GFXENV_ERROR_DELAY_CALIBRATION     = 0x04u,   /**< SMIF delay calibration failed */
} cy_gfxenv_en_result_t;

/**
* Display type presets
*/
typedef enum
{
    CY_GFXENV_DISP_TYPE_NONE = 0,              /**< No display */
    CY_GFXENV_DISP_TYPE_480_272_60_TTL,        /**< Display with resolution  480x272, refresh rate 60 Hz, RGB TTL interface */
    CY_GFXENV_DISP_TYPE_640_480_60_TTL,        /**< Display with resolution  640x480, refresh rate 60 Hz, RGB TTL interface */
    CY_GFXENV_DISP_TYPE_800_480_60_TTL,        /**< Display with resolution  800x480, refresh rate 60 Hz, RGB TTL interface */
    CY_GFXENV_DISP_TYPE_800_480_60_FPD_JEIDA,  /**< Display with resolution  800x480, refresh rate 60 Hz, FPD-Link interface, signal mapping according to JEIDA standard */
    CY_GFXENV_DISP_TYPE_800_480_60_FPD_VESA,   /**< Display with resolution  800x480, refresh rate 60 Hz, FPD-Link interface, signal mapping according to VESA standard */
    CY_GFXENV_DISP_TYPE_1280_768_60_FPD_VESA,  /**< Display with resolution 1280x768, refresh rate 60 Hz, FPD-Link interface, signal mapping according to VESA standard */
    CY_GFXENV_DISP_TYPE_1600_480_60_FPD_VESA,  /**< Display with resolution 1600x480, refresh rate 60 Hz, FPD-Link interface, signal mapping according to VESA standard */
} cy_gfxenv_en_disp_type_t;

/**
* External memory types (not all types are supported by all GfxEnv implementations!)
*/
typedef enum
{
    CY_GFXENV_EXTMEM_TYPE_S27KXXXX1,  /**< S27K HyperRAM Gen1 */
    CY_GFXENV_EXTMEM_TYPE_S27KXXXX2,  /**< S27K HyperRAM Gen2 */
    CY_GFXENV_EXTMEM_TYPE_S26K,       /**< S26K HyperFlash */
    CY_GFXENV_EXTMEM_TYPE_S26H,       /**< S26H SemperFlash with HyperBus Interface */
    CY_GFXENV_EXTMEM_TYPE_S28H,       /**< S28H SemperFlash with Octal Interface */
} cy_gfxenv_en_extmem_type_t;

/** \} group_gfxenv_enums */


/***************************************
*       Configuration Structure
***************************************/

/**
* \addtogroup group_gfxenv_data_structures
* \{
*/


/**
* Controls which port functions shall be initialized
*/
typedef struct
{
    bool  bInitDisplay0Ttl;       /**< Select whether port pins with Display #0 TTL signals shall be initialized */
    bool  bInitDisplay1Ttl;       /**< Select whether port pins with Display #1 TTL signals shall be initialized */
    bool  bInitCapture0Ttl;       /**< Select whether port pins with Capture #0 TTL signals shall be initialized */
    bool  bInitSmif0;             /**< Select whether port pins with SMIF #0 "instance" or "core" (depending on IP revision) signals shall be initialized */
    bool  bInitSmif1;             /**< Select whether port pins with SMIF #1 "instance" or "core" (depending on IP revision) signals shall be initialized */
    bool  bInitBacklightDisp0;    /**< Select whether port pins with backlight control signals for Display #0 shall be initialized (see schematics, typically only needed if PWM control is required) */
    bool  bInitBacklightDisp1;    /**< Select whether port pins with backlight control signals for Display #1 shall be initialized (see schematics, typically only needed if PWM control is required) */
    bool  bInitBacklightFpdLink0; /**< Select whether port pins with backlight control signals for Display #0 FPD-Link shall be initialized (see schematics, typically only needed if PWM control is required) */
    bool  bInitBacklightFpdLink1; /**< Select whether port pins with backlight control signals for Display #1 FPD-Link shall be initialized (see schematics, typically only needed if PWM control is required) */
    bool  bInitButtonGpios;       /**< Select whether port pins connected the buttons shall be initialized */
} cy_gfxenv_stc_init_portpins_t;


/**
* Controls SMIF_DEVICE HyperBus initialization
*/
typedef struct
{
    uint32_t                    u32BaseAddress;            /**< Base address to be used for memory mapping this device (must be part of the corresponding total SMIFn_XIP address space and aligned to the size) */
    uint16_t                    u16SizeMegaBytes;          /**< Configure how many megabytes shall be reserved in memory map for this device (Minimum value: 1 MB, use power of 2) */
    cy_gfxenv_en_extmem_type_t  enExtMemType;              /**< Select the type of the connected memory */
    /*--- Following members are don't care for tviic2d6m ---*/
    int32_t                     i32CalibrationDataOffset;  /**< Offset address where the calibration data pattern is located in the memory or where it shall be written/programmed to. Resulting address must be 16-byte aligned! 
                                                                Positive values: u32BaseAddress + i32CalibrationDataOffset; Negative Values: u32BaseAddress + (u16SizeMegaBytes * 1024 * 1024) - i32CalibrationDataOffset   */
    bool                        bEraseIfNecessary;         /**< In case of HyperFlash allows the driver to erase the sector where the calibration data should be located if the actual content is not blank or does not match the pattern. Don'T care for HyperRAM */
    bool                        bUseDifferentialClock;     /**< Select whether the connected memory will be configured to expect a differential clock input (not applicable for all memories) */
} cy_gfxenv_stc_smif_device_cfg_t;


/**
* Controls SMIF HyperBus initialization
*/
typedef struct
{
    uint8_t                            u8SmifExtClockMhz;                                  /**< Specify the SMIF clock frequency (chip external) that shall be applied for this SMIF.
                                                                                                IMPORTANT: The ratio of all defined SMIF frequencies needs to be 1, 2, 4 or 8 (or 1, 0.5, 0.25, 0.125 respectively) */
    cy_gfxenv_stc_smif_device_cfg_t *  apstcDevUsrCfg[CY_GFXENV_NR_OF_DEVICES_PER_SMIF];   /**< Select which SMIF_DEVICE instance shall be initialized by providing a pointer to the SMIF device cfg struct or NULL.
                                                                                                IMPORTANT: Only one device is supported at the moment, assign a NULL pointer to the not used device! */
} cy_gfxenv_stc_smif_cfg_t;


/**
* Controls external memory initialization
*/
typedef struct
{    
    bool                        bInitMpuTemporarily;                  /**< Select whether GfxEnv shall temporarily configure an MPU region covering SMIF #0 and #1 "instance" or "core" (depending on IP revision) XIP space during the initialization phase */
    uint8_t                     u8MpuRegionTemp;                      /**< Specify which MPU region to use if #bInitMpuTemporarily is set to 'true' */
    cy_gfxenv_stc_smif_cfg_t *  apstcInitSmif[CY_GFXENV_NR_OF_SMIF];  /**< Select which SMIF "instances" or "cores" (depending on IP revision) shall be initialized by providing a pointer to the SMIF cfg struct or NULL */
} cy_gfxenv_stc_init_extmem_t;


/**
* Controls button initialization
*/
typedef struct
{
    uint8_t               u8CySwTimerId;  /**< Select which SW Timer ID shall be used by the Button driver for its periodic processing (e.g. debouncing and callout) */
    cy_button_callback_t  pfnCallback;    /**< User function that will be called by button driver when a button state changes */
} cy_gfxenv_stc_init_buttons_t;


/**
* Initialization configuration structure for the GFX environment
*/
typedef struct
{
    bool                             bInitSwTimer;      /**< Select whether SW Timer module shall be initialized */
    bool                             bInitSemihosting;  /**< Select whether semihosting (including clock and port pins) shall be initialized */
    cy_gfxenv_stc_init_portpins_t *  pstcInitPortPins;  /**< Select whether port pins shall be initialized by providing a pointer to the port pin cfg struct or NULL */
    cy_gfxenv_stc_init_extmem_t *    pstcInitExtMem;    /**< Select whether ext memories shall be initialized by providing a pointer to the ext mem cfg struct or NULL */
    cy_gfxenv_stc_init_buttons_t *   pstcInitButtons;   /**< Select whether button driver shall be initialized by providing a pointer to the button cfg struct or NULL */
} cy_gfxenv_stc_cfg_t;

/** \} group_gfxenv_data_structures */

/******************************************************************************/
/*                      Display Backlight Controls                            */
/******************************************************************************/

/* Display 1 Backlight, available on P13/3 */
#define CY_BL_DISP1_PWM_PORT                    GPIO_PRT7
#define CY_BL_DISP1_PWM_PIN                     5
#define CY_BL_DISP1_PWM_PIN_MUX                 P7_5_GPIO  /* use as GPIO for now (0% or 100% PWM)*/


/******************************************************************************/
/*                      Display #1 Definitions                                */
/******************************************************************************/

/* Display 1 is connected to the FX3*/

#define CY_BSP_HDR_DISP1_TTL_AVAILABLE          /* Definitions for this functionality are available*/

#define CY_DISP1_CLK_PORT                       GPIO_PRT21
#define CY_DISP1_CLK_PIN                        1
#define CY_DISP1_CLK_PIN_MUX                    P21_1_VIDEOSS0_TTL_DSP1_CLOCK    /* PCLK*/

#define CY_DISP1_CTRL0_PORT                     GPIO_PRT20
#define CY_DISP1_CTRL0_PIN                      6
#define CY_DISP1_CTRL0_PIN_MUX                  P20_6_VIDEOSS0_TTL_DSP1_CONTROL0 /* LVALID*/

#define CY_DISP1_CTRL1_PORT                     GPIO_PRT20
#define CY_DISP1_CTRL1_PIN                      7
#define CY_DISP1_CTRL1_PIN_MUX                  P20_7_VIDEOSS0_TTL_DSP1_CONTROL1 /* VSYNC*/

#define CY_DISP1_CTRL2_PORT                     GPIO_PRT21
#define CY_DISP1_CTRL2_PIN                      0
#define CY_DISP1_CTRL2_PIN_MUX                  P21_0_VIDEOSS0_TTL_DSP1_CONTROL2 /* DE*/

#define CY_DISP1_DATA_A0_0_PORT                 GPIO_PRT16
#define CY_DISP1_DATA_A0_0_PIN                  7
#define CY_DISP1_DATA_A0_0_PIN_MUX              P16_7_VIDEOSS0_TTL_DSP1_DATA_A00 /* RED0*/

#define CY_DISP1_DATA_A1_0_PORT                 GPIO_PRT17
#define CY_DISP1_DATA_A1_0_PIN                  0
#define CY_DISP1_DATA_A1_0_PIN_MUX              P17_0_VIDEOSS0_TTL_DSP1_DATA_A10 /* RED1*/

#define CY_DISP1_DATA_A0_1_PORT                 GPIO_PRT18
#define CY_DISP1_DATA_A0_1_PIN                  0
#define CY_DISP1_DATA_A0_1_PIN_MUX              P18_0_VIDEOSS0_TTL_DSP1_DATA_A01 /* RED2*/

#define CY_DISP1_DATA_A1_1_PORT                 GPIO_PRT18
#define CY_DISP1_DATA_A1_1_PIN                  1
#define CY_DISP1_DATA_A1_1_PIN_MUX              P18_1_VIDEOSS0_TTL_DSP1_DATA_A11 /* RED3*/

#define CY_DISP1_DATA_A0_2_PORT                 GPIO_PRT18
#define CY_DISP1_DATA_A0_2_PIN                  2
#define CY_DISP1_DATA_A0_2_PIN_MUX              P18_2_VIDEOSS0_TTL_DSP1_DATA_A02 /* RED4*/

#define CY_DISP1_DATA_A1_2_PORT                 GPIO_PRT18
#define CY_DISP1_DATA_A1_2_PIN                  3
#define CY_DISP1_DATA_A1_2_PIN_MUX              P18_3_VIDEOSS0_TTL_DSP1_DATA_A12 /* RED5*/

#define CY_DISP1_DATA_A0_3_PORT                 GPIO_PRT18
#define CY_DISP1_DATA_A0_3_PIN                  4
#define CY_DISP1_DATA_A0_3_PIN_MUX              P18_4_VIDEOSS0_TTL_DSP1_DATA_A03 /* RED6*/

#define CY_DISP1_DATA_A1_3_PORT                 GPIO_PRT18
#define CY_DISP1_DATA_A1_3_PIN                  5
#define CY_DISP1_DATA_A1_3_PIN_MUX              P18_5_VIDEOSS0_TTL_DSP1_DATA_A13 /* RED7*/

#define CY_DISP1_DATA_A0_4_PORT                 GPIO_PRT18
#define CY_DISP1_DATA_A0_4_PIN                  6
#define CY_DISP1_DATA_A0_4_PIN_MUX              P18_6_VIDEOSS0_TTL_DSP1_DATA_A04 /* GREEN0*/

#define CY_DISP1_DATA_A1_4_PORT                 GPIO_PRT18
#define CY_DISP1_DATA_A1_4_PIN                  7
#define CY_DISP1_DATA_A1_4_PIN_MUX              P18_7_VIDEOSS0_TTL_DSP1_DATA_A14 /* GREEN1*/

#define CY_DISP1_DATA_A0_5_PORT                 GPIO_PRT19
#define CY_DISP1_DATA_A0_5_PIN                  0
#define CY_DISP1_DATA_A0_5_PIN_MUX              P19_0_VIDEOSS0_TTL_DSP1_DATA_A05 /* GREEN2*/

#define CY_DISP1_DATA_A1_5_PORT                 GPIO_PRT19
#define CY_DISP1_DATA_A1_5_PIN                  1
#define CY_DISP1_DATA_A1_5_PIN_MUX              P19_1_VIDEOSS0_TTL_DSP1_DATA_A15 /* GREEN3*/

#define CY_DISP1_DATA_A0_6_PORT                 GPIO_PRT19
#define CY_DISP1_DATA_A0_6_PIN                  2
#define CY_DISP1_DATA_A0_6_PIN_MUX              P19_2_VIDEOSS0_TTL_DSP1_DATA_A06 /* GREEN4*/

#define CY_DISP1_DATA_A1_6_PORT                 GPIO_PRT19
#define CY_DISP1_DATA_A1_6_PIN                  3
#define CY_DISP1_DATA_A1_6_PIN_MUX              P19_3_VIDEOSS0_TTL_DSP1_DATA_A16 /* GREEN5*/

#define CY_DISP1_DATA_A0_7_PORT                 GPIO_PRT19
#define CY_DISP1_DATA_A0_7_PIN                  4
#define CY_DISP1_DATA_A0_7_PIN_MUX              P19_4_VIDEOSS0_TTL_DSP1_DATA_A07 /* GREEN6*/

#define CY_DISP1_DATA_A1_7_PORT                 GPIO_PRT19
#define CY_DISP1_DATA_A1_7_PIN                  5
#define CY_DISP1_DATA_A1_7_PIN_MUX              P19_5_VIDEOSS0_TTL_DSP1_DATA_A17 /* GREEN7*/

#define CY_DISP1_DATA_A0_8_PORT                 GPIO_PRT19
#define CY_DISP1_DATA_A0_8_PIN                  6
#define CY_DISP1_DATA_A0_8_PIN_MUX              P19_6_VIDEOSS0_TTL_DSP1_DATA_A08 /* BLUE0*/

#define CY_DISP1_DATA_A1_8_PORT                 GPIO_PRT19
#define CY_DISP1_DATA_A1_8_PIN                  7
#define CY_DISP1_DATA_A1_8_PIN_MUX              P19_7_VIDEOSS0_TTL_DSP1_DATA_A18 /* BLUE1*/

#define CY_DISP1_DATA_A0_9_PORT                 GPIO_PRT20
#define CY_DISP1_DATA_A0_9_PIN                  0
#define CY_DISP1_DATA_A0_9_PIN_MUX              P20_0_VIDEOSS0_TTL_DSP1_DATA_A09 /* BLUE2*/

#define CY_DISP1_DATA_A1_9_PORT                 GPIO_PRT20
#define CY_DISP1_DATA_A1_9_PIN                  1
#define CY_DISP1_DATA_A1_9_PIN_MUX              P20_1_VIDEOSS0_TTL_DSP1_DATA_A19 /* BLUE3*/

#define CY_DISP1_DATA_A0_10_PORT                GPIO_PRT20
#define CY_DISP1_DATA_A0_10_PIN                 2
#define CY_DISP1_DATA_A0_10_PIN_MUX             P20_2_VIDEOSS0_TTL_DSP1_DATA_A010/* BLUE4*/

#define CY_DISP1_DATA_A1_10_PORT                GPIO_PRT20
#define CY_DISP1_DATA_A1_10_PIN                 3
#define CY_DISP1_DATA_A1_10_PIN_MUX             P20_3_VIDEOSS0_TTL_DSP1_DATA_A110/* BLUE5*/

#define CY_DISP1_DATA_A0_11_PORT                GPIO_PRT20
#define CY_DISP1_DATA_A0_11_PIN                 4
#define CY_DISP1_DATA_A0_11_PIN_MUX             P20_4_VIDEOSS0_TTL_DSP1_DATA_A011/* BLUE6*/

#define CY_DISP1_DATA_A1_11_PORT                GPIO_PRT20
#define CY_DISP1_DATA_A1_11_PIN                 5
#define CY_DISP1_DATA_A1_11_PIN_MUX             P20_5_VIDEOSS0_TTL_DSP1_DATA_A111/* BLUE7*/


/******************************************************************************/
/*                      FPD-LINK to HDMI Definitions                          */
/******************************************************************************/

/* No need to configure FPDLINK io mux, it is a part of AMUXBUS.*/

/* FPD to HDMI reset pin */
#define CY_FPD_HDMI_RST_PORT                    GPIO_PRT2
#define CY_FPD_HDMI_RST_PIN                     5
#define CY_FPD_HDMI_RST_PIN_MUX                 P2_5_GPIO

/* FPD to HDMI communication I2C definitions */
#define CY_FPD_HDMI_I2C_TYPE                    SCB1

#define CY_FPD_HDMI_I2C_SDA_PORT                GPIO_PRT15
#define CY_FPD_HDMI_I2C_SDA_PIN                 2
#define CY_FPD_HDMI_I2C_SDA_PIN_MUX             P15_2_SCB1_I2C_SDA

#define CY_FPD_HDMI_I2C_SCL_PORT                GPIO_PRT15
#define CY_FPD_HDMI_I2C_SCL_PIN                 3
#define CY_FPD_HDMI_I2C_SCL_PIN_MUX             P15_3_SCB1_I2C_SCL

#define CY_FPD_HDMI_I2C_PCLK                    PCLK_SCB1_CLOCK
#define CY_FPD_HDMI_I2C_IRQN                    scb_1_interrupt_IRQn

/* FPD to HDMI audio definitions */
#define CY_FPD_HDMI_TDM_TYPE                    TDM0_TDM_STRUCT3
#define CY_FPD_HDMI_TDM_TX_IRQN                 tdm_0_interrupts_tx_3_IRQn

#define CY_FPD_HDMI_TX_SCK_PORT                 GPIO_PRT11
#define CY_FPD_HDMI_TX_SCK_PIN                  5
#define CY_FPD_HDMI_TX_SCK_PIN_MUX              P11_5_TDM0_TDM_TX_SCK3

#define CY_FPD_HDMI_TX_FSYNC_PORT               GPIO_PRT11
#define CY_FPD_HDMI_TX_FSYNC_PIN                6
#define CY_FPD_HDMI_TX_FSYNC_PIN_MUX            P11_6_TDM0_TDM_TX_FSYNC3

#define CY_FPD_HDMI_TX_SD_PORT                  GPIO_PRT11
#define CY_FPD_HDMI_TX_SD_PIN                   7
#define CY_FPD_HDMI_TX_SD_PIN_MUX               P11_7_TDM0_TDM_TX_SD3

/******************************************************************************/
/*                      MIPI CSI-2 Definitions                                */
/******************************************************************************/

/* No need to configure MIPI CSI io mux, it is a part of AMUXBUS.*/

/* MIPI power enable */
#define CY_MIPI_CSI_IO_PE_PORT                  GPIO_PRT12
#define CY_MIPI_CSI_IO_PE_PIN                   3
#define CY_MIPI_CSI_IO_PE_PIN_MUX               P12_3_GPIO

/* MIPI Low power mode enable */
#define CY_MIPI_CSI_IO_LE_PORT                  GPIO_PRT12
#define CY_MIPI_CSI_IO_LE_PIN                   4
#define CY_MIPI_CSI_IO_LE_PIN_MUX               P12_4_GPIO

/* MIPI CSI Communication Block */
#define CY_MIPI_CSI_I2C_TYPE                    SCB10

#define CY_MIPI_CSI_I2C_SDA_PORT                GPIO_PRT0
#define CY_MIPI_CSI_I2C_SDA_PIN                 0
#define CY_MIPI_CSI_I2C_SDA_PIN_MUX             P0_0_SCB10_I2C_SDA

#define CY_MIPI_CSI_I2C_SCL_PORT                GPIO_PRT0
#define CY_MIPI_CSI_I2C_SCL_PIN                 1
#define CY_MIPI_CSI_I2C_SCL_PIN_MUX             P0_1_SCB10_I2C_SCL

#define CY_MIPI_CSI_I2C_PCLK                    PCLK_SCB10_CLOCK
#define CY_MIPI_CSI_I2C_IRQN                    scb_10_interrupt_IRQn

/***************************************
*       Function Prototypes
***************************************/

/**
* \addtogroup group_gfxenv_functions
* \{
*/

/*******************************************************************************
* Function Name: Cy_GfxEnv_Init
********************************************************************************
*
* \brief  Initializes the GFX environment
*
* \param  pstcGfxEnvCfg : The pointer to the init configuration struct
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/
cy_gfxenv_en_result_t Cy_GfxEnv_Init(const cy_gfxenv_stc_cfg_t * pstcGfxEnvCfg);

/*******************************************************************************
* Function Name: Cy_GfxEnv_FastInit
********************************************************************************
*
* \brief  Initializes the GFX environment with most commonly used settings.
*         Only a limited number of parameters can be configured, e.g.
*         whether SMIF instances and connected memories are initialized
*         because this would stuck execution if memory is not connected or in
*         case of signal problems.
*
* \warning u8Smif0ExtClockMhz and u8Smif1ExtClockMhz ratio needs to be 1, 2, 4 or 8 
*          (or 1, 0.5, 0.25, 0.125 respectively) at the moment, because by default
*          the same source PLL is being used for all the SMIFs
*
* \param  u8Smif0ExtClockMhz : SMIF0 external clock frequency
*                              If value == 0, SMIF0 will not be initialized
*                              tviic2dm: 10..185
* \param  u8Smif1ExtClockMhz : SMIF1 external clock frequency,
*                              If value == 0, SMIF1 will not be initialized
*                              tviic2dm: 10..185
* \param  pfnButtonCallback  : Callback from button handler, can be NULL (then
*                              button driver and port pins are not initialized)
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/
cy_gfxenv_en_result_t Cy_GfxEnv_FastInit(uint8_t u8Smif0ExtClockMhz, uint8_t u8Smif1ExtClockMhz, cy_button_callback_t pfnButtonCallback);


/*******************************************************************************
* Function Name: Cy_GfxEnv_EnableTestImage
********************************************************************************
*
* \brief  Enables the output of test images on the 2 display links
*
* \param  enDisp0Type : The display type to be setup for display link #0
* \param  enDisp1Type : The display type to be setup for display link #1
*
* \return cy_gfxenv_en_result_t
*
*******************************************************************************/
cy_gfxenv_en_result_t Cy_GfxEnv_EnableTestImage(cy_gfxenv_en_disp_type_t enDisp0Type, cy_gfxenv_en_disp_type_t enDisp1Type);

/*******************************************************************************
* Function Name: Cy_Fpdlink_Init
********************************************************************************
*
* \brief  Initiliza the FPDLINK
*
* \param  enFpdlink : FPD-Link Instance
* \param  pstcCfg : Settings for FPD-Link initialization
*
* \return cy_fpdlink_en_result_t
*
*******************************************************************************/
cy_fpdlink_en_result_t Cy_Fpdlink_Init(cy_fpdlink_en_instance_t enFpdlink, const cy_fpdlink_stc_cfg_t * pstcCfg);

/*******************************************************************************
* Function Name: Cy_SwTmr_GetTickCountUs
********************************************************************************
*
*  \brief : Systick interrupt handler
*
*  \param: None
*
*  \return: None
*
**********************************************************************************/
uint64_t Cy_SwTmr_GetTickCountUs(void);

/*******************************************************************************
* Function Name: toggle_led_on_systick_handler
********************************************************************************
*
*  \brief : Systick interrupt handler
*
*  \param: None
*
*  \return: None
*
**********************************************************************************/
void toggle_led_on_systick_handler(void);

/*******************************************************************************
* Function Name: Cy_PD_Enable
********************************************************************************
*
*  \brief : Enable the graphics power
*
*  \param: None
*
*  \return: None
*
**********************************************************************************/
void Cy_PD_Enable(void);

/** \} group_gfxenv_functions */

#if defined(__cplusplus)
}
#endif

#endif /* CY_GFXENV_H */

/** \} group_gfxenv */

/* [] END OF FILE */
